# D1: å†¥ç‹æ˜Ÿæ˜Ÿéš›ç¶²çµ¡ï¼šåœ–è«–èˆ‡æœç´¢æ¼”ç®—æ³•

## ğŸš€ ä»»å‹™èƒŒæ™¯

æ­å–œï¼ä½ å·²ç¶“æŠµé”å¤ªé™½ç³»çš„é‚Šç•Œâ€”â€”å†¥ç‹æ˜Ÿå€åŸŸã€‚é€™è£¡æœ‰è¤‡é›œçš„æ˜Ÿéš›èˆªé“ç¶²çµ¡ï¼Œé€£æ¥è‘—å„å€‹å¤ªç©ºç«™å’Œå°è¡Œæ˜Ÿå¸¶ã€‚è¦åœ¨é€™å€‹ç¶²çµ¡ä¸­æ‰¾åˆ°æœ€ä½³è·¯å¾‘ï¼Œä½ éœ€è¦æŒæ¡ã€Œåœ–è«–ã€â€”â€”é›»è…¦ç§‘å­¸ä¸­æœ€å¼·å¤§çš„å·¥å…·ä¹‹ä¸€ã€‚

åœ–å¯ä»¥è¡¨ç¤ºä»»ä½•ã€Œç‰©ä»¶ä¹‹é–“çš„é—œä¿‚ã€ï¼š
- å¤ªç©ºç«™ä¹‹é–“çš„èˆªé“
- ç¤¾äº¤ç¶²çµ¡ä¸­çš„æœ‹å‹é—œä¿‚
- ç¶²é ä¹‹é–“çš„è¶…é€£çµ
- åŸå¸‚ä¹‹é–“çš„é“è·¯

## ğŸ“š çŸ¥è­˜é»èªªæ˜

### ä»€éº¼æ˜¯åœ–ï¼ˆGraphï¼‰ï¼Ÿ

åœ–ç”±å…©éƒ¨åˆ†çµ„æˆï¼š
- **é ‚é»ï¼ˆVertices/Nodesï¼‰**ï¼šç‰©ä»¶æœ¬èº«
- **é‚Šï¼ˆEdgesï¼‰**ï¼šç‰©ä»¶ä¹‹é–“çš„é€£æ¥

```
    A --- B
    |     |
    C --- D
```

### åœ–çš„é¡å‹

1. **ç„¡å‘åœ– vs æœ‰å‘åœ–**
   - ç„¡å‘åœ–ï¼šé‚Šæ²’æœ‰æ–¹å‘ï¼ˆé›™å‘é“è·¯ï¼‰
   - æœ‰å‘åœ–ï¼šé‚Šæœ‰æ–¹å‘ï¼ˆå–®è¡Œé“ï¼‰

2. **åŠ æ¬Šåœ– vs ç„¡æ¬Šåœ–**
   - ç„¡æ¬Šåœ–ï¼šæ‰€æœ‰é‚Šçš„ã€Œæˆæœ¬ã€ç›¸åŒ
   - åŠ æ¬Šåœ–ï¼šæ¯æ¢é‚Šæœ‰ä¸åŒçš„æ¬Šé‡ï¼ˆè·é›¢ã€æ™‚é–“ç­‰ï¼‰

### åœ–çš„è¡¨ç¤ºæ³•

**1. é„°æ¥çŸ©é™£ï¼ˆAdjacency Matrixï¼‰**
```python
# é©åˆç¨ å¯†åœ–ï¼ŒæŸ¥è©¢å¿«ä½†ä½”ç©ºé–“
graph = [[0, 1, 1, 0],
         [1, 0, 0, 1],
         [1, 0, 0, 1],
         [0, 1, 1, 0]]
```

**2. é„°æ¥ä¸²åˆ—ï¼ˆAdjacency Listï¼‰** âœ… æ¨è–¦
```python
# é©åˆç¨€ç–åœ–ï¼Œç¯€çœç©ºé–“
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
```

### åœ–çš„éæ­·

**å»£åº¦å„ªå…ˆæœå°‹ï¼ˆBFSï¼‰**ï¼šä¸€å±¤ä¸€å±¤æ¢ç´¢
- ä½¿ç”¨ä½‡åˆ—ï¼ˆQueueï¼‰
- æ‰¾æœ€çŸ­è·¯å¾‘ï¼ˆç„¡æ¬Šåœ–ï¼‰

**æ·±åº¦å„ªå…ˆæœå°‹ï¼ˆDFSï¼‰**ï¼šä¸€æ¢è·¯èµ°åˆ°åº•
- ä½¿ç”¨å †ç–Šï¼ˆStackï¼‰æˆ–éè¿´
- æ¢ç´¢æ‰€æœ‰è·¯å¾‘

## ğŸ’» ç¯„ä¾‹ç¨‹å¼ç¢¼

### ç¯„ä¾‹ 1ï¼šå»ºç«‹æ˜Ÿéš›èˆªé“ç¶²çµ¡

```python
import sys
from collections import defaultdict

# ä»»å‹™ï¼šå»ºç«‹å¤ªç©ºç«™ç¶²çµ¡
n = int(sys.stdin.readline())  # å¤ªç©ºç«™æ•¸é‡
m = int(sys.stdin.readline())  # èˆªé“æ•¸é‡

# ä½¿ç”¨é„°æ¥ä¸²åˆ—
graph = defaultdict(list)

print("å»ºç«‹èˆªé“ï¼š")
for _ in range(m):
    a, b = map(int, sys.stdin.readline().strip().split())
    graph[a].append(b)
    graph[b].append(a)  # ç„¡å‘åœ–
    print(f"å¤ªç©ºç«™ {a} â†” å¤ªç©ºç«™ {b}")

print("\nç¶²çµ¡çµæ§‹ï¼š")
for station in sorted(graph.keys()):
    neighbors = sorted(graph[station])
    print(f"å¤ªç©ºç«™ {station}: é€£æ¥åˆ° {neighbors}")
```

### ç¯„ä¾‹ 2ï¼šBFS - æœ€çŸ­è·¯å¾‘æœç´¢

```python
import sys
from collections import deque, defaultdict

def bfs_shortest_path(graph, start, end):
    """ä½¿ç”¨ BFS æ‰¾å‡ºæœ€çŸ­è·¯å¾‘"""
    if start == end:
        return [start]
    
    # ä½‡åˆ—ï¼šå„²å­˜ (ç•¶å‰ç¯€é», è·¯å¾‘)
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        current, path = queue.popleft()
        
        # æ¢ç´¢æ‰€æœ‰é„°å±…
        for neighbor in graph[current]:
            if neighbor in visited:
                continue
            
            new_path = path + [neighbor]
            
            # æ‰¾åˆ°ç›®æ¨™
            if neighbor == end:
                return new_path
            
            visited.add(neighbor)
            queue.append((neighbor, new_path))
    
    return None  # ç„¡æ³•åˆ°é”

# ä»»å‹™ï¼šæ‰¾å‡ºå¾åœ°çƒåˆ°å†¥ç‹æ˜Ÿçš„æœ€çŸ­èˆªé“
n = int(sys.stdin.readline())
m = int(sys.stdin.readline())

graph = defaultdict(list)
for _ in range(m):
    a, b = map(int, sys.stdin.readline().strip().split())
    graph[a].append(b)
    graph[b].append(a)

start = int(sys.stdin.readline())
end = int(sys.stdin.readline())

path = bfs_shortest_path(graph, start, end)

if path:
    print(f"æœ€çŸ­è·¯å¾‘ï¼š{' â†’ '.join(map(str, path))}")
    print(f"éœ€è¦ç¶“é {len(path) - 1} å€‹èˆªé“")
else:
    print("ç„¡æ³•åˆ°é”ç›®æ¨™ï¼")
```

### ç¯„ä¾‹ 3ï¼šDFS - æ¢ç´¢æ‰€æœ‰è·¯å¾‘

```python
import sys
from collections import defaultdict

def dfs_all_paths(graph, start, end, path=[]):
    """ä½¿ç”¨ DFS æ‰¾å‡ºæ‰€æœ‰è·¯å¾‘"""
    path = path + [start]
    
    # åˆ°é”ç›®æ¨™
    if start == end:
        return [path]
    
    # æ²’æœ‰é„°å±…
    if start not in graph:
        return []
    
    paths = []
    for neighbor in graph[start]:
        # é¿å…å¾ªç’°
        if neighbor not in path:
            new_paths = dfs_all_paths(graph, neighbor, end, path)
            paths.extend(new_paths)
    
    return paths

# ä»»å‹™ï¼šæ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„æ¢ç´¢è·¯ç·š
n = int(sys.stdin.readline())
m = int(sys.stdin.readline())

graph = defaultdict(list)
for _ in range(m):
    a, b = map(int, sys.stdin.readline().strip().split())
    graph[a].append(b)
    graph[b].append(a)

start = int(sys.stdin.readline())
end = int(sys.stdin.readline())

all_paths = dfs_all_paths(graph, start, end)

print(f"æ‰¾åˆ° {len(all_paths)} æ¢è·¯å¾‘ï¼š\n")
for i, path in enumerate(all_paths, 1):
    print(f"è·¯å¾‘ {i}: {' â†’ '.join(map(str, path))}")
```

### ç¯„ä¾‹ 4ï¼šè¿·å®®æ¢ç´¢ï¼ˆç¶²æ ¼åœ–ï¼‰

```python
import sys
from collections import deque

def maze_bfs(maze, start, end):
    """åœ¨è¿·å®®ä¸­æ‰¾æœ€çŸ­è·¯å¾‘"""
    rows = len(maze)
    cols = len(maze[0])
    
    # å››å€‹æ–¹å‘ï¼šä¸Šä¸‹å·¦å³
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    direction_names = ['ä¸Š', 'ä¸‹', 'å·¦', 'å³']
    
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        (r, c), path = queue.popleft()
        
        # åˆ°é”çµ‚é»
        if (r, c) == end:
            return path
        
        # æ¢ç´¢å››å€‹æ–¹å‘
        for (dr, dc), name in zip(directions, direction_names):
            nr, nc = r + dr, c + dc
            
            # æª¢æŸ¥é‚Šç•Œ
            if 0 <= nr < rows and 0 <= nc < cols:
                # æª¢æŸ¥æ˜¯å¦å¯é€šè¡Œä¸”æœªè¨ªå•
                if maze[nr][nc] != '#' and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    queue.append(((nr, nc), path + [(nr, nc)]))
    
    return None

# ä»»å‹™ï¼šåœ¨å°è¡Œæ˜Ÿå¸¶ä¸­æ‰¾åˆ°å®‰å…¨è·¯å¾‘
# '.' = å®‰å…¨å€åŸŸ, '#' = éš•çŸ³, 'S' = èµ·é», 'E' = çµ‚é»
rows = int(sys.stdin.readline())
cols = int(sys.stdin.readline())

maze = []
start = end = None

for i in range(rows):
    row = list(sys.stdin.readline().strip())
    maze.append(row)
    for j in range(cols):
        if row[j] == 'S':
            start = (i, j)
            maze[i][j] = '.'
        elif row[j] == 'E':
            end = (i, j)
            maze[i][j] = '.'

path = maze_bfs(maze, start, end)

if path:
    print(f"æ‰¾åˆ°å®‰å…¨è·¯å¾‘ï¼é•·åº¦ï¼š{len(path)}")
    print("\nè¿·å®®ï¼ˆæ¨™è¨˜è·¯å¾‘ï¼‰ï¼š")
    
    # æ¨™è¨˜è·¯å¾‘
    for r, c in path:
        if (r, c) != start and (r, c) != end:
            maze[r][c] = '*'
    
    maze[start[0]][start[1]] = 'S'
    maze[end[0]][end[1]] = 'E'
    
    for row in maze:
        print(''.join(row))
else:
    print("ç„¡æ³•æ‰¾åˆ°å®‰å…¨è·¯å¾‘ï¼")
```

### ç¯„ä¾‹ 5ï¼šé€£é€šåˆ†é‡æª¢æ¸¬

```python
import sys
from collections import defaultdict

def find_connected_components(graph, n):
    """æ‰¾å‡ºåœ–ä¸­çš„æ‰€æœ‰é€£é€šåˆ†é‡"""
    visited = set()
    components = []
    
    def dfs(node, component):
        visited.add(node)
        component.append(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, component)
    
    for node in range(1, n + 1):
        if node not in visited:
            component = []
            dfs(node, component)
            components.append(sorted(component))
    
    return components

# ä»»å‹™ï¼šè­˜åˆ¥ç¨ç«‹çš„æ˜Ÿç³»ç¾¤
n = int(sys.stdin.readline())  # å¤ªç©ºç«™æ•¸é‡
m = int(sys.stdin.readline())  # èˆªé“æ•¸é‡

graph = defaultdict(list)
for _ in range(m):
    a, b = map(int, sys.stdin.readline().strip().split())
    graph[a].append(b)
    graph[b].append(a)

components = find_connected_components(graph, n)

print(f"ç™¼ç¾ {len(components)} å€‹ç¨ç«‹æ˜Ÿç³»ç¾¤ï¼š\n")
for i, comp in enumerate(components, 1):
    print(f"æ˜Ÿç³»ç¾¤ {i}: {comp}")
    print(f"  åŒ…å« {len(comp)} å€‹å¤ªç©ºç«™")
```

## ğŸ” ç¨‹å¼ç¢¼è§£èªª

### é—œéµæŠ€è¡“é»

1. **BFS vs DFS çš„é¸æ“‡**
   
   | ç‰¹æ€§ | BFS | DFS |
   |------|-----|-----|
   | æ•¸æ“šçµæ§‹ | ä½‡åˆ— | å †ç–Š/éè¿´ |
   | æœ€çŸ­è·¯å¾‘ | âœ… ä¿è­‰ | âŒ ä¸ä¿è­‰ |
   | è¨˜æ†¶é«” | è¼ƒå¤š | è¼ƒå°‘ |
   | é©ç”¨å ´æ™¯ | æœ€çŸ­è·¯å¾‘ | è·¯å¾‘å­˜åœ¨æ€§ |

2. **visited é›†åˆçš„é‡è¦æ€§**
   ```python
   visited = set()  # é˜²æ­¢é‡è¤‡è¨ªå•
   
   # åœ¨æœ‰ç’°çš„åœ–ä¸­ï¼Œæ²’æœ‰ visited æœƒç„¡é™å¾ªç’°ï¼
   ```

3. **ç¶²æ ¼åœ–çš„æŠ€å·§**
   ```python
   # å››å€‹æ–¹å‘çš„ç§»å‹•
   directions = [(-1,0), (1,0), (0,-1), (0,1)]
   
   for dr, dc in directions:
       new_r, new_c = r + dr, c + dc
       # æª¢æŸ¥é‚Šç•Œ
       if 0 <= new_r < rows and 0 <= new_c < cols:
           # è™•ç†
   ```

4. **defaultdict çš„å¦™ç”¨**
   ```python
   from collections import defaultdict
   
   # è‡ªå‹•å‰µå»ºç©ºåˆ—è¡¨
   graph = defaultdict(list)
   graph[1].append(2)  # ä¸éœ€è¦å…ˆåˆå§‹åŒ– graph[1]
   ```

## ğŸ“ Quizï¼šæ˜Ÿéš›æ•‘æ´ä»»å‹™

### é¡Œç›®ï¼šå¤šç›®æ¨™æœ€çŸ­è·¯å¾‘

ä½ çš„å¤ªç©ºèˆ¹åœ¨å¤ªç©ºç«™ Sï¼Œéœ€è¦æ•‘æ´ä½æ–¼å¤ªç©ºç«™ T1 å’Œ T2 çš„å…©çµ„å¤ªç©ºäººï¼Œç„¶å¾Œè¿”å›åŸºåœ° Eã€‚

è«‹æ‰¾å‡ºä¸€æ¢è·¯å¾‘ï¼Œä½¿å¾—ç¸½èˆªé“æ•¸æœ€å°‘ã€‚ä½ å¯ä»¥é¸æ“‡å…ˆæ•‘æ´ T1 æˆ– T2ã€‚

**è¼¸å…¥æ ¼å¼ï¼š**
- ç¬¬ä¸€è¡Œï¼šN Mï¼ˆå¤ªç©ºç«™æ•¸é‡ï¼Œèˆªé“æ•¸é‡ï¼‰
- æ¥ä¸‹ä¾† M è¡Œï¼šæ¯è¡Œå…©å€‹æ•´æ•¸ a bï¼Œè¡¨ç¤ºå¤ªç©ºç«™ a å’Œ b ä¹‹é–“æœ‰èˆªé“
- æœ€å¾Œä¸€è¡Œï¼šS T1 T2 Eï¼ˆèµ·é»ã€å…©å€‹æ•‘æ´é»ã€çµ‚é»ï¼‰

**è¼¸å…¥ç¯„ä¾‹ï¼š**
```
6 7
1 2
1 3
2 4
3 4
4 5
4 6
5 6
1 2 5 6
```

**è¼¸å‡ºç¯„ä¾‹ï¼š**
```
æœ€ä½³è·¯å¾‘ï¼š1 â†’ 2 â†’ 4 â†’ 5 â†’ 4 â†’ 6
ç¸½èˆªé“æ•¸ï¼š5

æ•‘æ´é †åºï¼š
1. å¾èµ·é» 1 åˆ°æ•‘æ´é» 2
2. å¾æ•‘æ´é» 2 åˆ°æ•‘æ´é» 5
3. å¾æ•‘æ´é» 5 åˆ°çµ‚é» 6
```

### ğŸ’¡ æç¤º
- ä½¿ç”¨ BFS è¨ˆç®—ä»»æ„å…©é»é–“çš„æœ€çŸ­è·é›¢
- æ¯”è¼ƒå…©ç¨®é †åºï¼šSâ†’T1â†’T2â†’E å’Œ Sâ†’T2â†’T1â†’E
- é¸æ“‡ç¸½è·é›¢è¼ƒçŸ­çš„è·¯å¾‘

---

## âœ… Quiz è§£ç­”

```python
import sys
from collections import deque, defaultdict

def bfs_distance(graph, start, end):
    """è¨ˆç®—å¾ start åˆ° end çš„æœ€çŸ­è·é›¢"""
    if start == end:
        return 0, [start]
    
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        current, path = queue.popleft()
        
        for neighbor in graph[current]:
            if neighbor in visited:
                continue
            
            new_path = path + [neighbor]
            
            if neighbor == end:
                return len(new_path) - 1, new_path
            
            visited.add(neighbor)
            queue.append((neighbor, new_path))
    
    return float('inf'), []

# è®€å–è¼¸å…¥
n, m = map(int, sys.stdin.readline().strip().split())

graph = defaultdict(list)
for _ in range(m):
    a, b = map(int, sys.stdin.readline().strip().split())
    graph[a].append(b)
    graph[b].append(a)

S, T1, T2, E = map(int, sys.stdin.readline().strip().split())

# è¨ˆç®—æ‰€æœ‰éœ€è¦çš„è·é›¢
dist_S_T1, path_S_T1 = bfs_distance(graph, S, T1)
dist_S_T2, path_S_T2 = bfs_distance(graph, S, T2)
dist_T1_T2, path_T1_T2 = bfs_distance(graph, T1, T2)
dist_T2_T1, path_T2_T1 = bfs_distance(graph, T2, T1)
dist_T1_E, path_T1_E = bfs_distance(graph, T1, E)
dist_T2_E, path_T2_E = bfs_distance(graph, T2, E)

# æ–¹æ¡ˆ 1ï¼šS â†’ T1 â†’ T2 â†’ E
route1_dist = dist_S_T1 + dist_T1_T2 + dist_T2_E
route1_path = path_S_T1[:-1] + path_T1_T2[:-1] + path_T2_E

# æ–¹æ¡ˆ 2ï¼šS â†’ T2 â†’ T1 â†’ E
route2_dist = dist_S_T2 + dist_T2_T1 + dist_T1_E
route2_path = path_S_T2[:-1] + path_T2_T1[:-1] + path_T1_E

# é¸æ“‡è¼ƒçŸ­çš„è·¯å¾‘
if route1_dist <= route2_dist:
    best_path = route1_path
    best_dist = route1_dist
    order = [T1, T2]
else:
    best_path = route2_path
    best_dist = route2_dist
    order = [T2, T1]

print(f"æœ€ä½³è·¯å¾‘ï¼š{' â†’ '.join(map(str, best_path))}")
print(f"ç¸½èˆªé“æ•¸ï¼š{best_dist}")
print(f"\næ•‘æ´é †åºï¼š")
print(f"1. å¾èµ·é» {S} åˆ°æ•‘æ´é» {order[0]}")
print(f"2. å¾æ•‘æ´é» {order[0]} åˆ°æ•‘æ´é» {order[1]}")
print(f"3. å¾æ•‘æ´é» {order[1]} åˆ°çµ‚é» {E}")
```

### è§£ç­”èªªæ˜

1. **åˆ†æ®µè¨ˆç®—**
   - å°‡å•é¡Œåˆ†è§£ç‚ºå¤šå€‹å…©é»é–“æœ€çŸ­è·¯å¾‘
   - ä½¿ç”¨ BFS è¨ˆç®—æ¯æ®µè·é›¢

2. **æ¯”è¼ƒå…©ç¨®æ–¹æ¡ˆ**
   ```python
   # æ–¹æ¡ˆ 1ï¼šS â†’ T1 â†’ T2 â†’ E
   # æ–¹æ¡ˆ 2ï¼šS â†’ T2 â†’ T1 â†’ E
   # é¸æ“‡ç¸½è·é›¢è¼ƒçŸ­çš„
   ```

3. **è·¯å¾‘æ‹¼æ¥**
   ```python
   # æ³¨æ„ï¼šæ‹¼æ¥æ™‚è¦å»æ‰ä¸­é–“ç¯€é»çš„é‡è¤‡
   path_S_T1[:-1] + path_T1_T2[:-1] + path_T2_E
   ```

---

## ğŸ¯ è¨“ç·´å®Œæˆï¼

æ­å–œä½ å®Œæˆå†¥ç‹æ˜Ÿæ˜Ÿéš›ç¶²çµ¡è¨“ç·´ï¼ä½ ç¾åœ¨å·²ç¶“æŒæ¡ï¼š
- âœ… åœ–çš„åŸºæœ¬æ¦‚å¿µèˆ‡è¡¨ç¤ºæ³•
- âœ… BFSï¼šæœ€çŸ­è·¯å¾‘æœç´¢
- âœ… DFSï¼šæ·±åº¦æ¢ç´¢
- âœ… ç¶²æ ¼åœ–çš„è™•ç†
- âœ… é€£é€šåˆ†é‡æª¢æ¸¬
- âœ… å¤šç›®æ¨™è·¯å¾‘è¦åŠƒ

**ä¸‹ä¸€ç«™ï¼šçµ‚æ¥µæŒ‘æˆ° - å‹•æ…‹è¦åŠƒï¼**

---

## ğŸ”— APCS å°æ‡‰èƒ½åŠ›
- **ç´šåˆ†ç›®æ¨™**ï¼š5 ç´šåˆ†
- **è©•é‡é …ç›®**ï¼šåœ–è«–ã€BFSã€DFS
- **å°æ‡‰é¡Œå‹**ï¼še287 (æ©Ÿå™¨äººçš„è·¯å¾‘)ã€i401 (é›·å°„æ¸¬è©¦)ã€b967 (è¡€ç·£é—œä¿‚)
- **æ ¸å¿ƒæŠ€èƒ½**ï¼šåœ–çš„éæ­·ã€æœ€çŸ­è·¯å¾‘ã€ç‹€æ…‹ç©ºé–“æœç´¢
